<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | lianghaijun的博客]]></title>
  <link href="http://lianghaijun.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://lianghaijun.com/"/>
  <updated>2013-12-31T14:35:25+08:00</updated>
  <id>http://lianghaijun.com/</id>
  <author>
    <name><![CDATA[seavers]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[insertBefore]]></title>
    <link href="http://lianghaijun.com/blog/1743767"/>
    <updated>2012-12-07T15:10:00+08:00</updated>
    <id>http://lianghaijun.com/blog/1743767</id>
    <content type="html"><![CDATA[<p>insertBefore</p>

<p>经常看到这样的写法:
[code=&ldquo;js&rdquo;]
if (head.firstChild) {</p>

<pre><code>head.insertBefore(node, head.firstChild);
</code></pre>

<p>} else {</p>

<pre><code>head.appendChild(node);
</code></pre>

<p>}
<code>
其实可以改为:
[code="js"]
head.insertBefore(node, head.firstChild);
</code></p>

<ul>
<li>insertBefore的第二参数为空时, 相当于appendChild</li>
<li>head.firstChild为空时, insertBefore等同于appendChild</li>
<li>jquery中的getScript时, 就是只有一句 insertBefore</li>
</ul>


<p>另外:</p>

<ul>
<li>IE6,IE7,IE8 下的head默认不是空的, 有一个文本空节点, head.childNodes.length === 1</li>
<li>IE9下面时, 如有<head></head>, 为1个文本节点, 内容为一个回车符</li>
<li>IE9下面时, 如没有head标签, 与chrome一致,  节点数为0</li>
<li>chrome时, <head></head>与没有head标签,均一致, 节点数为0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[isFunction]]></title>
    <link href="http://lianghaijun.com/blog/1743758"/>
    <updated>2012-12-07T15:03:00+08:00</updated>
    <id>http://lianghaijun.com/blog/1743758</id>
    <content type="html"><![CDATA[<p>[size=xx-large]isFunction</p>

<p>[size=large]标准写法是:
[code=&ldquo;js&rdquo;]
 var isFunction = function(obj) {</p>

<pre><code>   return Object.prototype.toString.call(obj) === '[object Function]'
</code></pre>

<p> }
```</p>

<p>[size=large]深层次:</p>

<ul>
<li>有博客说, 之前的chrome会识别 new Regexp()为function, 没有测试之前的chrome, 现在的不会了</li>
<li>有博客说, document.write在IE下会识别为object, 其实新的写法, 依然还是object, 不信,jquery测试下, 同理getAttribute也是一样的</li>
<li>jquery的isFunction注释
<code>
  // See test/unit/core.js for details concerning isFunction.
  // Since version 1.3, DOM methods and functions like alert
  // aren't supported. They return false on IE (#2968).
  isFunction: function( obj ) {
      return jQuery.type(obj) === "function";
  }
</code></li>
<li>jquery中的 type(obj), 即是  Object.prototype.toString.call(obj)</li>
<li>jquery已经不支持DOM方法,以及像alert这样的方法, 因为他们在IE都返回false,无法区分</li>
<li><h1>2968 见 [url]<a href="http://bugs.jquery.com/ticket/2968">http://bugs.jquery.com/ticket/2968</a>[/url]</h1></li>
</ul>


<p>[size=large]最简单的写法:
[code=&ldquo;js&rdquo;]
 var isFunction = function(obj) {</p>

<pre><code>   return typeof obj === 'function'
</code></pre>

<p> }
```</p>

<ul>
<li>这个写法, 在jquery的isFunction测试用例中, 全部通过  [url]<a href="https://code.google.com/p/jqueryjs/source/browse/trunk/jquery/test/unit/core.js">https://code.google.com/p/jqueryjs/source/browse/trunk/jquery/test/unit/core.js</a>[/url]</li>
<li>简单的就是最好的~~</li>
</ul>


<p>[size=large]测试用例 (修改自jquery的isFunction测试用例)
[code=&ldquo;html&rdquo;]
<body></p>

<ul id="result"></ul>




<script>
var jQuery = {
    isFunction: function(obj) {
        return typeof obj === 'function'
    }
}

function ok(bool, text) {
    document.getElementById('result').innerHTML += ('<li>' + (bool ? '√':'×') + ' &nbsp; ' + text);
}

function test() {
        // Make sure that false values return false
        ok( !jQuery.isFunction(), "No Value" );
        ok( !jQuery.isFunction( null ), "null Value" );
        ok( !jQuery.isFunction( undefined ), "undefined Value" );
        ok( !jQuery.isFunction( "" ), "Empty String Value" );
        ok( !jQuery.isFunction( 0 ), "0 Value" );

        // Check built-ins
        // Safari uses "(Internal Function)"
        ok( jQuery.isFunction(String), "String Function("+String+")" );
        ok( jQuery.isFunction(Array), "Array Function("+Array+")" );
        ok( jQuery.isFunction(Object), "Object Function("+Object+")" );
        ok( jQuery.isFunction(Function), "Function Function("+Function+")" );

        // When stringified, this could be misinterpreted
        var mystr = "function";
        ok( !jQuery.isFunction(mystr), "Function String" );

        // When stringified, this could be misinterpreted
        var myarr = [ "function" ];
        ok( !jQuery.isFunction(myarr), "Function Array" );

        // When stringified, this could be misinterpreted
        var myfunction = { "function": "test" };
        ok( !jQuery.isFunction(myfunction), "Function Object" );

        // Make sure normal functions still work
        var fn = function(){};
        ok( jQuery.isFunction(fn), "Normal Function" );

        var obj = document.createElement("object");

        // Firefox says this is a function
        ok( !jQuery.isFunction(obj), "Object Element" );

        // IE says this is an object
        // Since 1.3, this isn't supported (#2968)
        //ok( jQuery.isFunction(obj.getAttribute), "getAttribute Function" );

        var nodes = document.body.childNodes;

        // Safari says this is a function
        ok( !jQuery.isFunction(nodes), "childNodes Property" );

        var first = document.body.firstChild;

        // Normal elements are reported ok everywhere
        ok( !jQuery.isFunction(first), "A normal DOM Element" );

        var input = document.createElement("input");
        input.type = "text";
        document.body.appendChild( input );

        // IE says this is an object
        // Since 1.3, this isn't supported (#2968)
        //ok( jQuery.isFunction(input.focus), "A default function property" );

        document.body.removeChild( input );

        var a = document.createElement("a");
        a.href = "some-function";
        document.body.appendChild( a );

        // This serializes with the word 'function' in it
        ok( !jQuery.isFunction(a), "Anchor Element" );

        document.body.removeChild( a );

        // Recursive function calls have lengths and array-like properties
        function callme(callback){
                function fn(response){
                        callback(response);
                }

                ok( jQuery.isFunction(fn), "Recursive Function Call" );

                fn({ some: "data" });
        };

        callme(function(){
                callme(function(){});
        });
}

test();

</script>


<p></body></p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[function 工具集]]></title>
    <link href="http://lianghaijun.com/blog/1729814"/>
    <updated>2012-11-19T22:09:00+08:00</updated>
    <id>http://lianghaijun.com/blog/1729814</id>
    <content type="html"><![CDATA[<p>function 工具集</p>

<p>经常会碰到这样的问题
1. button.click 后，只调用一次方法
2. window.scroll触发太频繁，导致滚动加载次数太多
3. document.keyup次数太多，导致智能提示调用次数太多</p>

<p>你需要以下的方法来解决此类问题</p>

<p>[code=&ldquo;js&rdquo;]</p>

<p>$(&lsquo;a.load&rsquo;).on(&lsquo;click&rsquo;, $.once(function() {</p>

<pre><code> $('#tabs .first').load(url);
</code></pre>

<p>}));</p>

<p>$(window).on(&lsquo;scroll&rsquo;, $.throttle(function() {</p>

<pre><code> $('#rest').lazyload();    
</code></pre>

<p>}));</p>

<p>$(input).on(&lsquo;keyup&rsquo;, $.debounce(function() {</p>

<pre><code> $.suggest($(this).val())
</code></pre>

<p>}));</p>

<p>```</p>

<p>工具集源码如下：</p>

<p>[code=&ldquo;js&rdquo;]
$.bind = function(func, context) {</p>

<pre><code>  var args = Array.prototype.slice.call(arguments, 2);
  return function() {
      return  func.apply(context, args);
  }
</code></pre>

<p>}</p>

<p>//只调用一次
$.once = function(func){</p>

<pre><code>    var ran = false;
return function() {
    if(ran) return;
    ran = true;
    func();
}
</code></pre>

<p>}</p>

<p>//ms时间内只执行一次
$.throttle = function(func, ms) {
   ms = ms || 150;</p>

<p>   var last = +new Date();
   var timer ;</p>

<pre><code>return function() {
    var now = +new Date();
    if(now - last &gt; ms) {
         timer = null;
         last = now;
         func();
    } else {
         timer = setTimeout(func, ms - (now-last));
    }
}
</code></pre>

<p>}</p>

<p>//缓冲ms时间后才执行
$.debounce = function(func, ms) {</p>

<pre><code>   ms = ms || 150;

   var timer;
   return function() {
       clearTimeout(timer);
       timer = setTimeout(func, ms);
  }
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>underscore, yui 中有throttle, debounce两个方法, jquery中没有发现</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[判断两个字符串的相似度(js)]]></title>
    <link href="http://lianghaijun.com/blog/1681794"/>
    <updated>2012-09-19T20:48:00+08:00</updated>
    <id>http://lianghaijun.com/blog/1681794</id>
    <content type="html"><![CDATA[<p>问题来源于 [url]<a href="http://weibo.com/1748374882/yavpCkc31">http://weibo.com/1748374882/yavpCkc31</a>[/url]</p>

<p>问题：有两个字符串 A 和 B，如何简单高效的判断 A 和 B 的相似度？A 和 B 完全一样，相似度为 100, A 和 B 完全不一样，相似度为 0. A 和 B 中有一半文字相同，相似度为 50. 依此类推。文字中包含中英文，空白字符也算。哪位用 JS 挑战下？性能第一，代码长短无所谓。</p>

<p>[code=&ldquo;javascript&rdquo;]
function compare(x, y) {</p>

<pre><code>var z = 0;
var s = x.length + y.length;;

x.sort();
y.sort();
var a = x.shift();
var b = y.shift();

while(a !== undefined &amp;&amp; b !== undefined) {
    if (a === b) {
        z++;
        a = x.shift();
        b = y.shift();
    } else if (a &lt; b) {
        a = x.shift();
    } else if (a &gt; b) {
        b = y.shift();
    }
}
return z/s * 200;
</code></pre>

<p>}</p>

<p>console.log(compare([&lsquo;123&rsquo;, &lsquo;中文&rsquo;, &lsquo;hello&rsquo;], [&lsquo;123&rsquo;, &lsquo;中文&rsquo;, &lsquo;hello&rsquo;]))
console.log(compare([&lsquo;123&rsquo;, &lsquo;中文&rsquo;, &lsquo;hello&rsquo;], [&lsquo;123&rsquo;, &lsquo;中文&rsquo;, &lsquo;hello&rsquo;].sort()))
console.log(compare([&lsquo;123&rsquo;, &lsquo;中文&rsquo;, &lsquo;hello&rsquo;], [&lsquo;123&rsquo;, &lsquo;中文&rsquo;, &lsquo;hello&rsquo;].reverse()))
console.log(compare([&lsquo;123&rsquo;, &lsquo;中文&rsquo;, &lsquo;hello&rsquo;,&lsquo;中2文&rsquo;], [&lsquo;12&rsquo;, &lsquo;中2文&rsquo;, &lsquo;123&rsquo;,&lsquo;中文3&rsquo;]))
console.log(compare([&lsquo;123&rsquo;, &lsquo;中文&rsquo;, &lsquo;hello&rsquo;], [&lsquo;中文&rsquo;, &lsquo;world&rsquo;, &lsquo;456&rsquo;]))
console.log(compare([&lsquo;123&rsquo;, &lsquo;中3文&rsquo;, &lsquo;hello&rsquo;], [&lsquo;中文&rsquo;, &lsquo;world&rsquo;, &lsquo;汉字&rsquo;]))
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[js的简单串行加载方案]]></title>
    <link href="http://lianghaijun.com/blog/1676290"/>
    <updated>2012-09-12T00:29:00+08:00</updated>
    <id>http://lianghaijun.com/blog/1676290</id>
    <content type="html"><![CDATA[<p>写了一个超简单的串行加载工具, 不想引入框架时, 可以试用下</p>

<p>[code=&ldquo;javascript&rdquo;]
(function (all) {</p>

<pre><code>var callee = arguments.callee;
all.shift()(function(data) {
    callee.call(null, all, data);
});
</code></pre>

<p>})([</p>

<pre><code>function(next) {
    setTimeout(function() {
        document.body.innerHTML += '&lt;li&gt;first';

        next();
    }, 1000)
}, function(next) {
    setTimeout(function() {
        document.body.innerHTML += '&lt;li&gt;second';

        next();
    }, 2000)
}, function(next) {
    setTimeout(function() {
        document.body.innerHTML += '&lt;li&gt;third';

    }, 3000)
}
</code></pre>

<p>]);</p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
